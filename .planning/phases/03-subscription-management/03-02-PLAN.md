---
phase: 03-subscription-management
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - apps/web/app/api/stripe/callback/route.ts
  - apps/web/lib/stripe/webhook-handlers.ts
autonomous: true

must_haves:
  truths:
    - "Checkout completion upgrades user to paid status"
    - "Yearly and lifetime plans are distinguished by lookup_key or price.type"
    - "Duplicate webhook events return 200 without re-processing"
    - "stripeCustomerId is used as primary user lookup"
    - "Subscription cancellation reverts yearly users to free (not lifetime users)"
    - "No PII (email, payment amounts) appears in logs"
  artifacts:
    - path: "apps/web/app/api/stripe/callback/route.ts"
      provides: "Webhook endpoint with idempotency"
      exports: ["POST"]
    - path: "apps/web/lib/stripe/webhook-handlers.ts"
      provides: "Event-specific handler functions"
      exports: ["handleCheckoutComplete", "handleInvoicePaid", "handleSubscriptionDeleted"]
  key_links:
    - from: "apps/web/app/api/stripe/callback/route.ts"
      to: "@bragdoc/database"
      via: "checkEventProcessed, recordProcessedEvent"
      pattern: "checkEventProcessed|recordProcessedEvent"
    - from: "apps/web/lib/stripe/webhook-handlers.ts"
      to: "packages/database/src/schema.ts"
      via: "user table update"
      pattern: "update\\(user\\)"
---

<objective>
Rewrite Stripe webhook handler with idempotency, stripeCustomerId-first lookup, lookup_key plan detection, and proper lifetime handling.

Purpose: The current webhook handler has several issues identified in research: email-only lookup (fragile), no idempotency (duplicates), planId.split('_') parsing (won't work with new plan names), and console.log statements (PII exposure). This plan addresses all these issues.
Output: Production-ready webhook handler that safely processes yearly and lifetime purchases.
</objective>

<execution_context>
@/Users/ed/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ed/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-subscription-management/03-RESEARCH.md
@.planning/phases/03-subscription-management/03-01-SUMMARY.md

# Current webhook handler to refactor
@apps/web/app/api/stripe/callback/route.ts

# Database schema and queries
@packages/database/src/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create webhook handler module</name>
  <files>apps/web/lib/stripe/webhook-handlers.ts</files>
  <action>
Create new file `apps/web/lib/stripe/webhook-handlers.ts` with extracted handler functions.

IMPORTANT: Do NOT add any console.log, console.warn, or console.error statements that include email addresses, payment amounts, or other PII. Per SUBSCRIPTION-07, only event IDs and generic error messages may be logged.

```typescript
import type { Stripe } from 'stripe';
import { stripe } from './stripe';
import { user } from '@bragdoc/database/schema';
import { eq } from 'drizzle-orm';
import type { PgTransaction } from 'drizzle-orm/pg-core';

type DrizzleTx = PgTransaction<any, any, any>;

interface UserLookup {
  userId: string;
  lookupMethod: 'customerId' | 'email';
}

/**
 * Find user by stripeCustomerId (preferred) or email (fallback).
 * Returns null if user not found.
 *
 * IMPORTANT: Do NOT log email or other PII here per SUBSCRIPTION-07.
 */
export async function findUserForWebhook(
  tx: DrizzleTx,
  customerId: string | null,
  email: string | null,
): Promise<UserLookup | null> {
  // Try stripeCustomerId first (reliable even if email changes)
  if (customerId) {
    const byCustomerId = await tx
      .select({ id: user.id })
      .from(user)
      .where(eq(user.stripeCustomerId, customerId))
      .limit(1);

    if (byCustomerId.length > 0) {
      return { userId: byCustomerId[0].id, lookupMethod: 'customerId' };
    }
  }

  // Fallback to email (for first purchase before stripeCustomerId is set)
  if (email) {
    const byEmail = await tx
      .select({ id: user.id })
      .from(user)
      .where(eq(user.email, email))
      .limit(1);

    if (byEmail.length > 0) {
      // Return lookup method for metrics, but do NOT log the email value
      return { userId: byEmail[0].id, lookupMethod: 'email' };
    }
  }

  return null;
}

/**
 * Handle checkout.session.completed event.
 * Upgrades user to paid status based on plan type (yearly or lifetime).
 */
export async function handleCheckoutComplete(
  tx: DrizzleTx,
  session: Stripe.Checkout.Session,
): Promise<void> {
  // Skip unpaid checkouts
  if (session.payment_status !== 'paid') {
    return;
  }

  // Retrieve session with line items to get price details
  const expandedSession = await stripe.checkout.sessions.retrieve(session.id, {
    expand: ['line_items.data.price'],
  });

  const price = expandedSession.line_items?.data[0]?.price;
  if (!price) {
    throw new Error(`No price found for checkout session ${session.id}`);
  }

  // Determine plan type from price
  // - one_time = lifetime purchase
  // - recurring = yearly subscription
  const isLifetime = price.type === 'one_time';
  const renewalPeriod = isLifetime ? 'lifetime' : 'yearly';

  // Find user
  const userLookup = await findUserForWebhook(
    tx,
    session.customer as string | null,
    session.customer_details?.email ?? null,
  );

  if (!userLookup) {
    throw new Error(`User not found for checkout session ${session.id}`);
  }

  // Update user subscription in single UPDATE
  await tx
    .update(user)
    .set({
      level: 'paid',
      renewalPeriod,
      lastPayment: new Date(),
      stripeCustomerId: session.customer as string,
    })
    .where(eq(user.id, userLookup.userId));
}

/**
 * Handle invoice.paid event (subscription renewals).
 * Updates lastPayment date for yearly subscribers.
 */
export async function handleInvoicePaid(
  tx: DrizzleTx,
  invoice: Stripe.Invoice,
): Promise<void> {
  // Only process subscription invoices (not one-time payments)
  if (!invoice.subscription) {
    return;
  }

  const customerId = invoice.customer as string;
  if (!customerId) {
    return;
  }

  // Update last payment date
  await tx
    .update(user)
    .set({
      lastPayment: new Date(),
    })
    .where(eq(user.stripeCustomerId, customerId));
}

/**
 * Handle customer.subscription.deleted event.
 * Reverts yearly subscribers to free tier (skips lifetime users).
 */
export async function handleSubscriptionDeleted(
  tx: DrizzleTx,
  subscription: Stripe.Subscription,
): Promise<void> {
  const customerId = subscription.customer as string;
  if (!customerId) {
    return;
  }

  // Check if user is lifetime (shouldn't have subscriptions, but guard anyway)
  const userRecord = await tx
    .select({ renewalPeriod: user.renewalPeriod })
    .from(user)
    .where(eq(user.stripeCustomerId, customerId))
    .limit(1);

  // Skip if lifetime user (one-time purchase, not subscription)
  if (userRecord[0]?.renewalPeriod === 'lifetime') {
    return;
  }

  // Revert to free tier
  await tx
    .update(user)
    .set({
      level: 'free',
      lastPayment: null,
    })
    .where(eq(user.stripeCustomerId, customerId));
}
```

Key patterns from research:
- stripeCustomerId-first lookup (SUBSCRIPTION-03)
- price.type to detect one_time vs recurring (Pattern 2)
- Lifetime guard on cancellation (Pattern 4)
- Single UPDATE statements (SUBSCRIPTION-05)
- No PII logging anywhere in this file (SUBSCRIPTION-07)
  </action>
  <verify>TypeScript compiles: `pnpm --filter=@bragdoc/web build`</verify>
  <done>Webhook handler functions created with proper lookup and lifetime handling</done>
</task>

<task type="auto">
  <name>Task 2: Refactor webhook route with idempotency</name>
  <files>apps/web/app/api/stripe/callback/route.ts</files>
  <action>
Completely rewrite the webhook route to use idempotency and the new handlers.

```typescript
import type { Stripe } from 'stripe';
import { NextResponse } from 'next/server';
import { stripe } from 'lib/stripe/stripe';
import { db } from '@/database/index';
import {
  checkEventProcessed,
  recordProcessedEvent,
} from '@bragdoc/database';
import {
  handleCheckoutComplete,
  handleInvoicePaid,
  handleSubscriptionDeleted,
} from 'lib/stripe/webhook-handlers';

const HANDLED_EVENTS = [
  'checkout.session.completed',
  'invoice.paid',
  'customer.subscription.deleted',
] as const;

type HandledEventType = (typeof HANDLED_EVENTS)[number];

function isHandledEvent(type: string): type is HandledEventType {
  return HANDLED_EVENTS.includes(type as HandledEventType);
}

export async function POST(req: Request) {
  let event: Stripe.Event;

  // 1. Verify webhook signature immediately
  try {
    const body = await req.text();
    const signature = req.headers.get('stripe-signature');

    if (!signature) {
      return NextResponse.json(
        { error: 'Missing stripe-signature header' },
        { status: 400 },
      );
    }

    event = stripe.webhooks.constructEvent(
      body,
      signature,
      process.env.STRIPE_WEBHOOK_SECRET as string,
    );
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Unknown error';
    return NextResponse.json(
      { error: `Webhook signature verification failed: ${message}` },
      { status: 400 },
    );
  }

  // 2. Skip unhandled event types early
  if (!isHandledEvent(event.type)) {
    return NextResponse.json({ received: true, handled: false });
  }

  // 3. Check idempotency (before any processing)
  const alreadyProcessed = await checkEventProcessed(event.id);
  if (alreadyProcessed) {
    return NextResponse.json({ received: true, duplicate: true });
  }

  // 4. Process event in transaction
  try {
    await db.transaction(async (tx) => {
      // Record event first (acts as idempotency lock)
      await recordProcessedEvent(tx, event.id, event.type);

      // Handle specific event types
      switch (event.type) {
        case 'checkout.session.completed':
          await handleCheckoutComplete(
            tx,
            event.data.object as Stripe.Checkout.Session,
          );
          break;

        case 'invoice.paid':
          await handleInvoicePaid(tx, event.data.object as Stripe.Invoice);
          break;

        case 'customer.subscription.deleted':
          await handleSubscriptionDeleted(
            tx,
            event.data.object as Stripe.Subscription,
          );
          break;
      }
    });
  } catch (error) {
    // Log error without PII (just event ID)
    const message = error instanceof Error ? error.message : 'Unknown error';
    // Note: In production, use structured logger instead
    console.error(`Webhook processing failed for event ${event.id}: ${message}`);

    // Return 500 to trigger Stripe retry
    return NextResponse.json(
      { error: 'Webhook processing failed' },
      { status: 500 },
    );
  }

  return NextResponse.json({ received: true, handled: true });
}
```

Key changes from original:
- Added idempotency check before processing (SUBSCRIPTION-04)
- Wrapped all processing in transaction (SUBSCRIPTION-05)
- Removed console.log with PII (SUBSCRIPTION-07)
- Removed payment_intent events (not needed for Payment Links)
- Uses new handler functions
- Returns informative but non-leaky responses
  </action>
  <verify>
1. TypeScript compiles: `pnpm --filter=@bragdoc/web build`
2. No console.log with PII in the file
  </verify>
  <done>Webhook route uses idempotency, transactions, and clean logging</done>
</task>

</tasks>

<verification>
1. `pnpm build` succeeds (no TypeScript errors across monorepo)
2. `pnpm test` passes (no regressions)
3. Grep for console.log in route.ts shows only event ID logging, no email/amounts
4. Code review: verify transaction wraps all database operations
</verification>

<success_criteria>
- Webhook handler extracts price.type to distinguish yearly from lifetime
- stripeCustomerId is used as primary lookup, email as fallback
- Duplicate events are detected and return 200 without processing
- All database updates happen within a single transaction
- Lifetime users are not downgraded on subscription.deleted
- No PII appears in log statements
</success_criteria>

<output>
After completion, create `.planning/phases/03-subscription-management/03-02-SUMMARY.md`
</output>
