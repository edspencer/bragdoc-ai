---
phase: 03-subscription-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/database/src/schema.ts
  - packages/database/src/stripe-events/queries.ts
  - packages/database/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Stripe event IDs can be stored in database for idempotency checks"
    - "Duplicate webhook events are detected before processing"
    - "Migration applies cleanly to existing database"
  artifacts:
    - path: "packages/database/src/schema.ts"
      provides: "StripeEvent table definition"
      contains: "stripeEvent"
    - path: "packages/database/src/stripe-events/queries.ts"
      provides: "Idempotency check and record functions"
      exports: ["checkEventProcessed", "recordProcessedEvent"]
  key_links:
    - from: "packages/database/src/stripe-events/queries.ts"
      to: "packages/database/src/schema.ts"
      via: "import stripeEvent"
      pattern: "from.*schema"
---

<objective>
Add StripeEvent table for webhook idempotency and create query utilities for checking/recording processed events.

Purpose: Stripe retries webhooks for up to 3 days. Without idempotency checks, duplicate events cause double user upgrades or other inconsistencies. This table provides the foundation for safe webhook handling.
Output: StripeEvent table in schema, migration applied, query utilities for use by webhook handler.
</objective>

<execution_context>
@/Users/ed/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ed/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-subscription-management/03-RESEARCH.md

# Existing schema patterns
@packages/database/src/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add StripeEvent table to schema</name>
  <files>packages/database/src/schema.ts</files>
  <action>
Add StripeEvent table to schema.ts following existing table patterns:

```typescript
export const stripeEvent = pgTable('StripeEvent', {
  id: varchar('id', { length: 64 }).primaryKey(), // Stripe event ID (evt_xxx)
  type: varchar('type', { length: 64 }).notNull(),
  processedAt: timestamp('processed_at').notNull().defaultNow(),
});

export type StripeEvent = InferSelectModel<typeof stripeEvent>;
```

Key considerations:
- Use varchar(64) for id (Stripe event IDs are ~27 chars, leave buffer)
- No UUID - use Stripe's event ID directly as primary key
- No foreign keys - standalone audit table
- Add export for type

Place table near end of file, after creditTransaction table (related audit infrastructure).
  </action>
  <verify>TypeScript compiles: `pnpm --filter=@bragdoc/database build`</verify>
  <done>StripeEvent table defined in schema with id, type, processedAt fields</done>
</task>

<task type="auto">
  <name>Task 2: Create stripe-events query module</name>
  <files>packages/database/src/stripe-events/queries.ts, packages/database/src/index.ts</files>
  <action>
Create new directory and file: `packages/database/src/stripe-events/queries.ts`

```typescript
import { db } from '../index';
import { stripeEvent } from '../schema';
import { eq } from 'drizzle-orm';
import type { PgTransaction } from 'drizzle-orm/pg-core';

type DrizzleTx = PgTransaction<any, any, any>;

/**
 * Check if a Stripe event has already been processed.
 * Use this BEFORE processing any webhook to prevent duplicate handling.
 */
export async function checkEventProcessed(eventId: string): Promise<boolean> {
  const existing = await db
    .select({ id: stripeEvent.id })
    .from(stripeEvent)
    .where(eq(stripeEvent.id, eventId))
    .limit(1);

  return existing.length > 0;
}

/**
 * Record a processed Stripe event within a transaction.
 * Call this at the START of the transaction (before business logic)
 * so the insert acts as an idempotency lock.
 */
export async function recordProcessedEvent(
  tx: DrizzleTx,
  eventId: string,
  eventType: string,
): Promise<void> {
  await tx.insert(stripeEvent).values({
    id: eventId,
    type: eventType,
  });
}
```

Then update packages/database/src/index.ts to export the queries:

Add to exports section:
```typescript
export * from './stripe-events/queries';
```
  </action>
  <verify>Build succeeds: `pnpm --filter=@bragdoc/database build`</verify>
  <done>checkEventProcessed and recordProcessedEvent functions exported from @bragdoc/database</done>
</task>

<task type="auto">
  <name>Task 3: Generate and apply migration</name>
  <files>packages/database/drizzle/*</files>
  <action>
Generate Drizzle migration for the new StripeEvent table:

```bash
cd packages/database && pnpm db:generate
```

Review the generated migration file to ensure it only creates the StripeEvent table.

Then push the schema to the database:

```bash
pnpm db:push
```

Note: Using db:push for development per CLAUDE.md guidelines. For production, the migration will be applied via db:migrate.
  </action>
  <verify>
1. `pnpm db:generate` creates migration without errors
2. `pnpm db:push` applies schema without errors
3. `pnpm db:studio` shows StripeEvent table in browser
  </verify>
  <done>StripeEvent table exists in database with id (PK), type, and processed_at columns</done>
</task>

</tasks>

<verification>
1. `pnpm --filter=@bragdoc/database build` succeeds
2. `pnpm test` passes (no regressions)
3. StripeEvent table visible in Drizzle Studio
4. Type exports work: can import { StripeEvent } from '@bragdoc/database/schema'
</verification>

<success_criteria>
- StripeEvent table exists in schema.ts with correct structure
- Query functions checkEventProcessed and recordProcessedEvent are exported
- Migration has been generated and applied
- No TypeScript errors in database package
</success_criteria>

<output>
After completion, create `.planning/phases/03-subscription-management/03-01-SUMMARY.md`
</output>
