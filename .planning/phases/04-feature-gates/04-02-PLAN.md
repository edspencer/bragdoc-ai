---
phase: 04-feature-gates
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/app/api/documents/[id]/chat/route.ts
  - apps/web/app/api/performance-review/chat/route.ts
  - apps/web/__tests__/api/credit-gates.test.ts

autonomous: true

must_haves:
  truths:
    - "Free user with 0 chat messages cannot send new messages"
    - "Free user chat messages decrement on each user message"
    - "Free user with 0 credits cannot use tools in chat"
    - "Paid users have unlimited chat messages"
    - "Demo users have unlimited chat messages"
    - "Blocked requests return 402 with upgrade URL"
  artifacts:
    - path: "apps/web/app/api/documents/[id]/chat/route.ts"
      provides: "Chat message gate and tool credit wrapper"
      contains: "checkUserChatMessages"
    - path: "apps/web/app/api/performance-review/chat/route.ts"
      provides: "Chat message gate and tool credit wrapper"
      contains: "checkUserChatMessages"
    - path: "apps/web/__tests__/api/credit-gates.test.ts"
      provides: "Unit tests for credit checking edge cases"
      contains: "describe.*credit.*gate"
  key_links:
    - from: "apps/web/app/api/documents/[id]/chat/route.ts"
      to: "lib/credits"
      via: "import and call deductChatMessage"
      pattern: "deductChatMessage\\("
    - from: "apps/web/app/api/documents/[id]/chat/route.ts"
      to: "lib/stripe/subscription"
      via: "hasUnlimitedAccess check"
      pattern: "hasUnlimitedAccess\\("
---

<objective>
Add chat message gates and tool credit handling to chatbot endpoints, plus unit tests.

Purpose: Ensure free users consume chat messages and credits for LLM-powered chat features. Each chat message costs 1 message from the free allowance. Each tool call (createDocument, updateDocument) costs 1 credit. Paid/demo users bypass all limits.

Output: Two modified chat route handlers with message and tool credit gating, plus comprehensive unit tests for credit checking edge cases.
</objective>

<execution_context>
@/Users/ed/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ed/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-feature-gates/04-RESEARCH.md

# Credit utilities from Phase 2
@apps/web/lib/credits/index.ts
@apps/web/lib/credits/costs.ts
@apps/web/lib/credits/check.ts
@apps/web/lib/credits/operations.ts

# Subscription status helper from Phase 3
@apps/web/lib/stripe/subscription.ts

# Endpoints to modify
@apps/web/app/api/documents/[id]/chat/route.ts
@apps/web/app/api/performance-review/chat/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add chat message gate to document chat endpoint</name>
  <files>
    apps/web/app/api/documents/[id]/chat/route.ts
  </files>
  <action>
Add chat message checking to the document chat endpoint. This gates the user's message submission.

1. Add imports at the top:
   ```typescript
   import { hasUnlimitedAccess } from '@/lib/stripe/subscription';
   import {
     checkUserChatMessages,
     deductChatMessage,
     checkUserCredits,
     deductCredits,
     logCreditTransaction,
     CREDIT_COSTS
   } from '@/lib/credits';
   ```

2. After fetching the document and verifying ownership (after the `if (currentDocument.userId !== user.id)` check), add the chat message gate:
   ```typescript
   // Chat message gate - skip for paid/demo users
   if (!hasUnlimitedAccess(user)) {
     const { hasMessages, remainingMessages } = checkUserChatMessages(user);

     if (!hasMessages) {
       return Response.json({
         error: 'insufficient_chat_messages',
         message: "You've used all 20 free messages. Upgrade for unlimited chat.",
         remaining: 0,
         upgradeUrl: '/pricing',
       }, { status: 402 });
     }

     // Atomic deduction
     const { success, remaining } = await deductChatMessage(user.id, user.level);
     if (!success) {
       return Response.json({
         error: 'insufficient_chat_messages',
         message: "Messages exhausted. Upgrade for unlimited chat.",
         remaining: 0,
         upgradeUrl: '/pricing',
       }, { status: 402 });
     }

     // Log the message deduction (non-blocking)
     logCreditTransaction({
       userId: user.id,
       operation: 'deduct',
       feature: 'chat_message',
       amount: 1,
       metadata: { documentId, remainingMessages: remaining },
     }).catch(err => console.error('Failed to log chat message transaction:', err));
   }
   ```

3. Create a tool wrapper function for credit checking (add before the POST function or as a module-level function):
   ```typescript
   /**
    * Wrap a tool with credit checking for free users.
    * Returns error object instead of throwing to maintain LLM conversation flow.
    */
   function wrapToolWithCreditCheck<T extends { execute: (...args: any[]) => Promise<any> }>(
     baseTool: T,
     user: User,
     cost: number
   ): T {
     return {
       ...baseTool,
       execute: async (...args: any[]) => {
         if (!hasUnlimitedAccess(user)) {
           const { hasCredits, remainingCredits } = checkUserCredits(user, cost);
           if (!hasCredits) {
             return {
               error: 'insufficient_credits',
               message: `This action requires ${cost} credit. You have ${remainingCredits} remaining. Upgrade for unlimited access.`,
             };
           }

           const { success } = await deductCredits(user.id, cost);
           if (!success) {
             return {
               error: 'insufficient_credits',
               message: 'Unable to complete action. Please try again.',
             };
           }

           // Log tool credit usage (non-blocking)
           logCreditTransaction({
             userId: user.id,
             operation: 'deduct',
             feature: 'chat_tool_call',
             amount: cost,
             metadata: { toolName: 'documentTool' },
           }).catch(err => console.error('Failed to log tool credit transaction:', err));
         }

         return baseTool.execute(...args);
       },
     } as T;
   }
   ```

4. Modify the tools object in the streaming response to wrap tools:
   ```typescript
   tools: {
     createDocument: wrapToolWithCreditCheck(
       createDocument({ user, dataStream }),
       user,
       CREDIT_COSTS.chat_tool_call
     ),
     updateDocument: wrapToolWithCreditCheck(
       updateDocument({ user, dataStream }),
       user,
       CREDIT_COSTS.chat_tool_call
     ),
   },
   ```

IMPORTANT: The tool wrapper returns an error object (not throws) to maintain LLM conversation flow. Throwing would break the stream.
  </action>
  <verify>
TypeScript compilation passes:
```bash
cd apps/web && pnpm tsc --noEmit
```
  </verify>
  <done>
Document chat endpoint includes:
- Chat message gate after document verification
- Tool credit wrapper function
- Both tools wrapped with credit checking
- Non-blocking transaction logging
  </done>
</task>

<task type="auto">
  <name>Task 2: Add chat message gate to performance review chat endpoint</name>
  <files>
    apps/web/app/api/performance-review/chat/route.ts
  </files>
  <action>
Add chat message checking to the performance review chat endpoint, following the same pattern as Task 1.

1. Add imports at the top:
   ```typescript
   import { hasUnlimitedAccess } from '@/lib/stripe/subscription';
   import {
     checkUserChatMessages,
     deductChatMessage,
     checkUserCredits,
     deductCredits,
     logCreditTransaction,
     CREDIT_COSTS
   } from '@/lib/credits';
   ```

2. After fetching the performance review (after the `if (!performanceReview)` check), add the chat message gate:
   ```typescript
   // Chat message gate - skip for paid/demo users
   if (!hasUnlimitedAccess(user)) {
     const { hasMessages, remainingMessages } = checkUserChatMessages(user);

     if (!hasMessages) {
       return Response.json({
         error: 'insufficient_chat_messages',
         message: "You've used all 20 free messages. Upgrade for unlimited chat.",
         remaining: 0,
         upgradeUrl: '/pricing',
       }, { status: 402 });
     }

     // Atomic deduction
     const { success, remaining } = await deductChatMessage(user.id, user.level);
     if (!success) {
       return Response.json({
         error: 'insufficient_chat_messages',
         message: "Messages exhausted. Upgrade for unlimited chat.",
         remaining: 0,
         upgradeUrl: '/pricing',
       }, { status: 402 });
     }

     // Log the message deduction (non-blocking)
     logCreditTransaction({
       userId: user.id,
       operation: 'deduct',
       feature: 'chat_message',
       amount: 1,
       metadata: { performanceReviewId, remainingMessages: remaining },
     }).catch(err => console.error('Failed to log chat message transaction:', err));
   }
   ```

3. Add the same tool wrapper function (copy from Task 1):
   ```typescript
   function wrapToolWithCreditCheck<T extends { execute: (...args: any[]) => Promise<any> }>(
     baseTool: T,
     user: User,
     cost: number
   ): T {
     return {
       ...baseTool,
       execute: async (...args: any[]) => {
         if (!hasUnlimitedAccess(user)) {
           const { hasCredits, remainingCredits } = checkUserCredits(user, cost);
           if (!hasCredits) {
             return {
               error: 'insufficient_credits',
               message: `This action requires ${cost} credit. You have ${remainingCredits} remaining. Upgrade for unlimited access.`,
             };
           }

           const { success } = await deductCredits(user.id, cost);
           if (!success) {
             return {
               error: 'insufficient_credits',
               message: 'Unable to complete action. Please try again.',
             };
           }

           // Log tool credit usage (non-blocking)
           logCreditTransaction({
             userId: user.id,
             operation: 'deduct',
             feature: 'chat_tool_call',
             amount: cost,
             metadata: { toolName: 'updatePerformanceReviewDocument' },
           }).catch(err => console.error('Failed to log tool credit transaction:', err));
         }

         return baseTool.execute(...args);
       },
     } as T;
   }
   ```

4. Wrap the tool in the streaming response:
   ```typescript
   tools: {
     updatePerformanceReviewDocument: wrapToolWithCreditCheck(
       updatePerformanceReviewDocument({
         user,
         dataStream,
         performanceReviewId,
       }),
       user,
       CREDIT_COSTS.chat_tool_call
     ),
   },
   ```

NOTE: This endpoint only has one tool (updatePerformanceReviewDocument), unlike the document chat which has two.
  </action>
  <verify>
TypeScript compilation passes:
```bash
cd apps/web && pnpm tsc --noEmit
```
  </verify>
  <done>
Performance review chat endpoint includes:
- Chat message gate after performance review verification
- Tool credit wrapper function
- updatePerformanceReviewDocument wrapped with credit checking
- Non-blocking transaction logging
  </done>
</task>

<task type="auto">
  <name>Task 3: Create unit tests for credit gate edge cases</name>
  <files>
    apps/web/__tests__/api/credit-gates.test.ts
  </files>
  <action>
Create comprehensive unit tests for the credit checking utilities. These test the core credit logic, not the full API endpoints.

Create new file `apps/web/__tests__/api/credit-gates.test.ts`:

```typescript
/**
 * Unit tests for credit gate edge cases (FEATURE-GATE-06)
 *
 * Tests the credit checking utilities used by all LLM-gated endpoints.
 * These are unit tests for the core logic, not integration tests for full endpoints.
 */

import { describe, it, expect, jest, beforeEach } from '@jest/globals';
import {
  checkUserCredits,
  checkUserChatMessages,
  type CreditCheckResult,
  type ChatMessageCheckResult,
} from '@/lib/credits';
import { hasUnlimitedAccess, getSubscriptionStatus } from '@/lib/stripe/subscription';
import type { User } from '@bragdoc/database';

// Helper to create test users with specific credit/subscription states
function createTestUser(overrides: Partial<User> = {}): User {
  return {
    id: 'test-user-id',
    email: 'test@example.com',
    name: 'Test User',
    emailVerified: true,
    createdAt: new Date(),
    updatedAt: new Date(),
    image: null,
    level: 'free',
    renewalPeriod: null,
    lastPayment: null,
    stripeCustomerId: null,
    freeCredits: 10,
    freeChatMessages: 20,
    preferences: null,
    banned: null,
    banReason: null,
    banExpires: null,
    ...overrides,
  } as User;
}

describe('Credit Gate Logic', () => {
  describe('checkUserCredits', () => {
    it('returns hasCredits=false when user has 0 credits', () => {
      const user = createTestUser({ freeCredits: 0, level: 'free' });
      const result = checkUserCredits(user, 1);

      expect(result.hasCredits).toBe(false);
      expect(result.remainingCredits).toBe(0);
      expect(result.isUnlimited).toBe(false);
    });

    it('returns hasCredits=false when user has fewer credits than required', () => {
      const user = createTestUser({ freeCredits: 1, level: 'free' });
      const result = checkUserCredits(user, 2);

      expect(result.hasCredits).toBe(false);
      expect(result.remainingCredits).toBe(1);
    });

    it('returns hasCredits=true when user has exact credits required', () => {
      const user = createTestUser({ freeCredits: 2, level: 'free' });
      const result = checkUserCredits(user, 2);

      expect(result.hasCredits).toBe(true);
      expect(result.remainingCredits).toBe(2);
    });

    it('returns hasCredits=true when user has more credits than required', () => {
      const user = createTestUser({ freeCredits: 10, level: 'free' });
      const result = checkUserCredits(user, 2);

      expect(result.hasCredits).toBe(true);
      expect(result.remainingCredits).toBe(10);
    });

    it('treats NULL freeCredits as default 10 for legacy users', () => {
      const user = createTestUser({ freeCredits: null, level: 'free' });
      const result = checkUserCredits(user, 5);

      expect(result.hasCredits).toBe(true);
      expect(result.remainingCredits).toBe(10);
    });
  });

  describe('checkUserChatMessages', () => {
    it('returns hasMessages=false when user has 0 messages', () => {
      const user = createTestUser({ freeChatMessages: 0, level: 'free' });
      const result = checkUserChatMessages(user);

      expect(result.hasMessages).toBe(false);
      expect(result.remainingMessages).toBe(0);
      expect(result.isUnlimited).toBe(false);
    });

    it('returns hasMessages=true when user has messages remaining', () => {
      const user = createTestUser({ freeChatMessages: 15, level: 'free' });
      const result = checkUserChatMessages(user);

      expect(result.hasMessages).toBe(true);
      expect(result.remainingMessages).toBe(15);
    });

    it('treats NULL freeChatMessages as default 20 for legacy users', () => {
      const user = createTestUser({ freeChatMessages: null, level: 'free' });
      const result = checkUserChatMessages(user);

      expect(result.hasMessages).toBe(true);
      expect(result.remainingMessages).toBe(20);
    });
  });

  describe('Paid user bypass', () => {
    it('allows paid users with 0 credits (unlimited)', () => {
      const user = createTestUser({
        freeCredits: 0,
        level: 'paid',
        renewalPeriod: 'lifetime',
      });
      const result = checkUserCredits(user, 100);

      expect(result.hasCredits).toBe(true);
      expect(result.remainingCredits).toBe(Infinity);
      expect(result.isUnlimited).toBe(true);
    });

    it('allows paid users with 0 chat messages (unlimited)', () => {
      const user = createTestUser({
        freeChatMessages: 0,
        level: 'paid',
        renewalPeriod: 'lifetime',
      });
      const result = checkUserChatMessages(user);

      expect(result.hasMessages).toBe(true);
      expect(result.remainingMessages).toBe(Infinity);
      expect(result.isUnlimited).toBe(true);
    });

    it('hasUnlimitedAccess returns true for lifetime paid users', () => {
      const user = createTestUser({
        level: 'paid',
        renewalPeriod: 'lifetime',
      });

      expect(hasUnlimitedAccess(user)).toBe(true);
    });

    it('hasUnlimitedAccess returns true for yearly paid users with valid subscription', () => {
      const user = createTestUser({
        level: 'paid',
        renewalPeriod: 'yearly',
        lastPayment: new Date(), // Just paid
      });

      expect(hasUnlimitedAccess(user)).toBe(true);
    });

    it('hasUnlimitedAccess returns false for expired yearly subscription', () => {
      const twoYearsAgo = new Date();
      twoYearsAgo.setFullYear(twoYearsAgo.getFullYear() - 2);

      const user = createTestUser({
        level: 'paid',
        renewalPeriod: 'yearly',
        lastPayment: twoYearsAgo,
      });

      expect(hasUnlimitedAccess(user)).toBe(false);
    });
  });

  describe('Demo user bypass', () => {
    it('allows demo users with 0 credits (unlimited)', () => {
      const user = createTestUser({
        freeCredits: 0,
        level: 'demo',
      });
      const result = checkUserCredits(user, 100);

      expect(result.hasCredits).toBe(true);
      expect(result.remainingCredits).toBe(Infinity);
      expect(result.isUnlimited).toBe(true);
    });

    it('allows demo users with 0 chat messages (unlimited)', () => {
      const user = createTestUser({
        freeChatMessages: 0,
        level: 'demo',
      });
      const result = checkUserChatMessages(user);

      expect(result.hasMessages).toBe(true);
      expect(result.remainingMessages).toBe(Infinity);
      expect(result.isUnlimited).toBe(true);
    });

    it('hasUnlimitedAccess returns true for demo users', () => {
      const user = createTestUser({ level: 'demo' });

      expect(hasUnlimitedAccess(user)).toBe(true);
    });
  });

  describe('Legacy tier handling', () => {
    it('treats legacy basic level as free (no unlimited access)', () => {
      const user = createTestUser({
        level: 'basic' as any,
        freeCredits: 0,
      });

      expect(hasUnlimitedAccess(user)).toBe(false);
    });

    it('treats legacy pro level as free (no unlimited access)', () => {
      const user = createTestUser({
        level: 'pro' as any,
        freeCredits: 0,
      });

      expect(hasUnlimitedAccess(user)).toBe(false);
    });
  });

  describe('Subscription status details', () => {
    it('returns correct status for lifetime subscription', () => {
      const user = createTestUser({
        level: 'paid',
        renewalPeriod: 'lifetime',
      });
      const status = getSubscriptionStatus(user);

      expect(status.isActive).toBe(true);
      expect(status.type).toBe('lifetime');
      expect(status.expiresAt).toBeUndefined();
      expect(status.daysRemaining).toBeUndefined();
    });

    it('returns correct status with daysRemaining for yearly subscription', () => {
      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

      const user = createTestUser({
        level: 'paid',
        renewalPeriod: 'yearly',
        lastPayment: thirtyDaysAgo,
      });
      const status = getSubscriptionStatus(user);

      expect(status.isActive).toBe(true);
      expect(status.type).toBe('yearly');
      expect(status.expiresAt).toBeDefined();
      // Should be approximately 335 days remaining (365 - 30)
      expect(status.daysRemaining).toBeGreaterThan(330);
      expect(status.daysRemaining).toBeLessThan(340);
    });

    it('returns correct status for free user', () => {
      const user = createTestUser({ level: 'free' });
      const status = getSubscriptionStatus(user);

      expect(status.isActive).toBe(false);
      expect(status.type).toBe('free');
    });

    it('returns correct status for demo user', () => {
      const user = createTestUser({ level: 'demo' });
      const status = getSubscriptionStatus(user);

      expect(status.isActive).toBe(true);
      expect(status.type).toBe('demo');
    });
  });
});
```

This test file:
- Tests zero credits blocking
- Tests paid user bypass
- Tests demo user bypass
- Tests legacy tier handling (basic/pro treated as free)
- Tests NULL credit defaults for legacy users
- Tests subscription status details

NOTE: Concurrent request testing (freeCredits=1 with 2 requests) requires database integration tests. The database CHECK constraint test is at the schema level. These unit tests cover the pure function logic.
  </action>
  <verify>
Run the tests:
```bash
cd apps/web && pnpm test credit-gates
```

TypeScript compilation passes:
```bash
cd apps/web && pnpm tsc --noEmit
```
  </verify>
  <done>
Unit tests created covering:
- Zero credits returns hasCredits=false
- Insufficient credits returns hasCredits=false
- Paid users bypass credit checks (returns unlimited)
- Demo users bypass credit checks (returns unlimited)
- Legacy basic/pro levels treated as free
- NULL credit defaults for legacy users
- Subscription status details for all user types
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes for all modified files:
   ```bash
   cd apps/web && pnpm tsc --noEmit
   ```

2. Tests pass:
   ```bash
   cd apps/web && pnpm test credit-gates
   ```

3. Build completes successfully:
   ```bash
   pnpm build
   ```

4. Manual verification (optional but recommended):
   - Start dev server: `pnpm dev`
   - Test chat endpoint as free user with 0 messages: should get 402
   - Test chat endpoint as paid user: should work without message deduction
   - Test tool call as free user with 0 credits: should get error in response
</verification>

<success_criteria>
- Both chat endpoints have message gates before processing
- Both chat endpoints have tool wrappers for credit checking
- Tools return error objects (not throw) when credits insufficient
- Unit tests pass for all credit gate edge cases
- TypeScript compilation and build pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-feature-gates/04-02-SUMMARY.md`
</output>
