---
phase: 04-feature-gates
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/app/api/documents/generate/route.ts
  - apps/web/app/api/performance-review/generate/route.ts
  - apps/web/app/api/workstreams/generate/route.ts

autonomous: true

must_haves:
  truths:
    - "Free user with 0 credits cannot generate documents"
    - "Free user with 0 credits cannot generate workstreams"
    - "Paid users bypass credit checks entirely"
    - "Demo users bypass credit checks entirely"
    - "Blocked requests return 402 with upgrade URL"
  artifacts:
    - path: "apps/web/app/api/documents/generate/route.ts"
      provides: "Credit-gated document generation"
      contains: "hasUnlimitedAccess"
    - path: "apps/web/app/api/performance-review/generate/route.ts"
      provides: "Credit-gated performance review generation"
      contains: "hasUnlimitedAccess"
    - path: "apps/web/app/api/workstreams/generate/route.ts"
      provides: "Credit-gated workstream generation"
      contains: "hasUnlimitedAccess"
  key_links:
    - from: "apps/web/app/api/documents/generate/route.ts"
      to: "lib/credits"
      via: "import and call"
      pattern: "import.*from.*lib/credits"
    - from: "apps/web/app/api/documents/generate/route.ts"
      to: "lib/stripe/subscription"
      via: "hasUnlimitedAccess check"
      pattern: "hasUnlimitedAccess\\(.*\\)"
---

<objective>
Add credit gates to document and workstream generation endpoints.

Purpose: Ensure free users consume credits for LLM-powered generation features, while paid/demo users have unlimited access. This enforces the monetization model at the API layer.

Output: Three modified route handlers that check credits before starting LLM operations, returning 402 Payment Required when credits are insufficient.
</objective>

<execution_context>
@/Users/ed/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ed/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-feature-gates/04-RESEARCH.md

# Credit utilities from Phase 2
@apps/web/lib/credits/index.ts
@apps/web/lib/credits/costs.ts
@apps/web/lib/credits/check.ts
@apps/web/lib/credits/operations.ts

# Subscription status helper from Phase 3
@apps/web/lib/stripe/subscription.ts

# Endpoints to modify
@apps/web/app/api/documents/generate/route.ts
@apps/web/app/api/performance-review/generate/route.ts
@apps/web/app/api/workstreams/generate/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add credit gate to document generation endpoints</name>
  <files>
    apps/web/app/api/documents/generate/route.ts
    apps/web/app/api/performance-review/generate/route.ts
  </files>
  <action>
Add credit checking to both document generation endpoints. The pattern is identical for both:

1. Import required utilities at the top:
   ```typescript
   import { hasUnlimitedAccess } from '@/lib/stripe/subscription';
   import { checkUserCredits, deductCredits, CREDIT_COSTS } from '@/lib/credits';
   ```

2. After auth validation and request body parsing (but BEFORE any LLM operations), add the credit gate:
   ```typescript
   // Credit gate - skip for paid/demo users
   if (!hasUnlimitedAccess(authUser)) {
     const cost = CREDIT_COSTS.document_generation[type] ?? 1;
     const { hasCredits, remainingCredits } = checkUserCredits(authUser, cost);

     if (!hasCredits) {
       return Response.json({
         error: 'insufficient_credits',
         message: `Document generation requires ${cost} credits. You have ${remainingCredits} remaining.`,
         required: cost,
         available: remainingCredits,
         upgradeUrl: '/pricing',
       }, { status: 402 });
     }

     // Atomic deduction
     const { success } = await deductCredits(authUser.id, cost);
     if (!success) {
       return Response.json({
         error: 'insufficient_credits',
         message: 'Credits consumed by concurrent request. Please try again.',
         upgradeUrl: '/pricing',
       }, { status: 402 });
     }
   }
   ```

For `/api/documents/generate/route.ts`:
- The `type` variable comes from `parsed.data.type`
- Place the gate after `const { achievementIds, type, title, ... } = parsed.data;`
- User is `authUser` from `const { user: authUser } = authResult;`

For `/api/performance-review/generate/route.ts`:
- Use `type = 'performance_review'` directly (hardcoded document type)
- Place the gate after request validation and before fetching performance review
- User is `auth.user`

IMPORTANT:
- Credit check MUST happen BEFORE any LLM operations start
- For streaming endpoints, check BEFORE `streamText()` is called
- Do NOT use `withCreditReservation` for streaming - deduct upfront (no refund on stream errors)
  </action>
  <verify>
TypeScript compilation passes:
```bash
cd apps/web && pnpm tsc --noEmit
```
  </verify>
  <done>
Both document generation endpoints import credit utilities and include credit gate logic that:
- Checks `hasUnlimitedAccess()` first (skips check for paid/demo)
- Gets cost from `CREDIT_COSTS.document_generation[type]`
- Returns 402 with structured JSON if insufficient credits
- Atomically deducts credits before LLM operation
  </done>
</task>

<task type="auto">
  <name>Task 2: Add credit gate to workstream generation endpoint</name>
  <files>
    apps/web/app/api/workstreams/generate/route.ts
  </files>
  <action>
Add credit checking to the workstream generation SSE endpoint. This endpoint creates a ReadableStream, so the credit check MUST happen BEFORE the stream is created.

1. Add imports at the top (with existing imports):
   ```typescript
   import { hasUnlimitedAccess } from '@/lib/stripe/subscription';
   import { checkUserCredits, deductCredits, CREDIT_COSTS } from '@/lib/credits';
   ```

2. Add credit gate AFTER auth check but BEFORE `const stream = new ReadableStream({...})`:
   ```typescript
   // Credit gate - BEFORE creating ReadableStream (cannot return 402 after stream starts)
   if (!hasUnlimitedAccess(auth.user)) {
     const cost = CREDIT_COSTS.workstream_clustering; // 2 credits
     const { hasCredits, remainingCredits } = checkUserCredits(auth.user, cost);

     if (!hasCredits) {
       return NextResponse.json({
         error: 'insufficient_credits',
         message: `Workstream generation requires ${cost} credits. You have ${remainingCredits} remaining.`,
         required: cost,
         available: remainingCredits,
         upgradeUrl: '/pricing',
       }, { status: 402 });
     }

     // Atomic deduction - must happen before stream
     const { success } = await deductCredits(auth.user.id, cost);
     if (!success) {
       return NextResponse.json({
         error: 'insufficient_credits',
         message: 'Credits consumed by concurrent request. Please try again.',
         upgradeUrl: '/pricing',
       }, { status: 402 });
     }
   }
   ```

CRITICAL: The credit gate must be placed BEFORE `const stream = new ReadableStream({`. Once the stream is created, we cannot return a 402 response - it would corrupt the SSE stream.

Placement in the code:
- After: `const userId = auth.user.id;`
- Before: `const encoder = new TextEncoder();` and `const stream = new ReadableStream({`

The workstream endpoint uses `auth.user` (not `authUser`), so use that consistently.
  </action>
  <verify>
TypeScript compilation passes:
```bash
cd apps/web && pnpm tsc --noEmit
```
  </verify>
  <done>
Workstream generation endpoint includes credit gate that:
- Checks `hasUnlimitedAccess(auth.user)` first
- Uses `CREDIT_COSTS.workstream_clustering` (2 credits)
- Returns 402 with JSON BEFORE stream creation
- Atomically deducts credits before SSE stream starts
  </done>
</task>

<task type="auto">
  <name>Task 3: Add credit transaction logging to generation endpoints</name>
  <files>
    apps/web/app/api/documents/generate/route.ts
    apps/web/app/api/performance-review/generate/route.ts
    apps/web/app/api/workstreams/generate/route.ts
  </files>
  <action>
Add transaction logging after successful credit deduction in all three endpoints. This uses the logger from Phase 2 (deferred until endpoints were integrated).

1. Add import to all three files:
   ```typescript
   import { logCreditTransaction } from '@/lib/credits';
   ```

2. After successful `deductCredits()` call, add logging. For `/api/documents/generate`:
   ```typescript
   const { success } = await deductCredits(authUser.id, cost);
   if (!success) {
     // ... existing 402 response
   }

   // Log the transaction (non-blocking)
   logCreditTransaction({
     userId: authUser.id,
     operation: 'deduct',
     feature: 'document_generation',
     amount: cost,
     metadata: { documentType: type, title },
   }).catch(err => console.error('Failed to log credit transaction:', err));
   ```

3. For `/api/performance-review/generate`:
   ```typescript
   // Log the transaction (non-blocking)
   logCreditTransaction({
     userId: auth.user.id,
     operation: 'deduct',
     feature: 'document_generation',
     amount: cost,
     metadata: { documentType: 'performance_review', performanceReviewId },
   }).catch(err => console.error('Failed to log credit transaction:', err));
   ```

4. For `/api/workstreams/generate`:
   ```typescript
   // Log the transaction (non-blocking)
   logCreditTransaction({
     userId: userId,
     operation: 'deduct',
     feature: 'workstream_generation',
     amount: cost,
     metadata: { filters: filters || {} },
   }).catch(err => console.error('Failed to log credit transaction:', err));
   ```

IMPORTANT: Use `.catch()` to make logging non-blocking. Credit logging failures should NOT fail the main operation (per Phase 2 decision).
  </action>
  <verify>
TypeScript compilation passes:
```bash
cd apps/web && pnpm tsc --noEmit
```

Build succeeds:
```bash
cd apps/web && pnpm build
```
  </verify>
  <done>
All three generation endpoints log credit transactions with:
- User ID
- Operation type ('deduct')
- Feature name
- Amount
- Relevant metadata (document type, title, filters)
- Non-blocking execution via .catch()
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes for all modified files
2. Build completes successfully: `pnpm build`
3. Manual verification (optional but recommended):
   - Start dev server: `pnpm dev`
   - Test as free user with 0 credits: should get 402 response
   - Test as paid user: should bypass credit check
   - Test as demo user: should bypass credit check
</verification>

<success_criteria>
- All three generation endpoints have credit gates
- Credit check happens BEFORE LLM operations
- `hasUnlimitedAccess()` correctly bypasses for paid/demo users
- 402 responses include structured JSON with upgradeUrl
- Credit transactions are logged (non-blocking)
- TypeScript compilation and build pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-feature-gates/04-01-SUMMARY.md`
</output>
