---
phase: 02-credit-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/lib/credits/costs.ts
  - apps/web/lib/credits/operations.ts
  - apps/web/lib/credits/errors.ts
  - apps/web/lib/credits/index.ts
autonomous: true

must_haves:
  truths:
    - "Credit deduction is atomic - concurrent requests cannot cause double-spending"
    - "Streaming LLM operations reserve credit at start and refund on failure"
    - "All credit costs are centralized in a single config file"
  artifacts:
    - path: "apps/web/lib/credits/costs.ts"
      provides: "Credit cost definitions per feature type"
      exports: ["CREDIT_COSTS"]
    - path: "apps/web/lib/credits/operations.ts"
      provides: "Atomic deduct, refund, and reservation functions"
      exports: ["deductCredits", "refundCredits", "deductChatMessage", "withCreditReservation"]
    - path: "apps/web/lib/credits/errors.ts"
      provides: "Credit-related error classes"
      exports: ["InsufficientCreditsError", "InsufficientChatMessagesError"]
  key_links:
    - from: "apps/web/lib/credits/operations.ts"
      to: "@bragdoc/database"
      via: "Drizzle sql template for atomic UPDATE"
      pattern: "sql`.*freeCredits.*-"
    - from: "apps/web/lib/credits/operations.ts"
      to: "apps/web/lib/credits/errors.ts"
      via: "import and throw"
      pattern: "throw new Insufficient.*Error"
---

<objective>
Create atomic credit deduction and reservation utilities for race-condition-safe credit operations.

Purpose: Implement the core credit system functions that will be used by feature gates in Phase 4 to deduct credits when users access LLM-powered features. These utilities must be atomic to prevent double-spending from concurrent requests.

Output: A `lib/credits/` module with deduct, refund, and reservation functions, plus centralized credit cost definitions.
</objective>

<execution_context>
@/Users/ed/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ed/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-credit-system/02-RESEARCH.md

@packages/database/src/schema.ts
@apps/web/lib/getAuthUser.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create credit costs configuration and error classes</name>
  <files>
    apps/web/lib/credits/costs.ts
    apps/web/lib/credits/errors.ts
  </files>
  <action>
Create the credits module directory structure at `apps/web/lib/credits/`.

**costs.ts:** Define CREDIT_COSTS constant with feature-specific costs:
```typescript
export const CREDIT_COSTS = {
  document_generation: {
    weekly_report: 1,
    performance_review: 2,
    brag_doc: 2,
  },
  workstream_clustering: 2,
  chat_tool_call: 1,
} as const;

export type DocumentType = keyof typeof CREDIT_COSTS.document_generation;
```

Include helper function `getDocumentCost(documentType: DocumentType): number` that returns the cost for a given document type.

**errors.ts:** Create error classes:
```typescript
export class InsufficientCreditsError extends Error {
  constructor(public required: number, public available?: number) {
    super(`Insufficient credits. Required: ${required}${available !== undefined ? `, Available: ${available}` : ''}`);
    this.name = 'InsufficientCreditsError';
  }
}

export class InsufficientChatMessagesError extends Error {
  constructor() {
    super("You've used all 20 free messages. Upgrade for unlimited chat.");
    this.name = 'InsufficientChatMessagesError';
  }
}
```
  </action>
  <verify>
    - `npx tsc --noEmit` passes (no TypeScript errors)
    - Files exist at expected paths
    - CREDIT_COSTS exports correctly with proper types
  </verify>
  <done>
    - Credit costs centralized in single file for easy adjustment
    - Error classes available for credit-gated operations
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement atomic credit deduction and reservation operations</name>
  <files>
    apps/web/lib/credits/operations.ts
    apps/web/lib/credits/index.ts
  </files>
  <action>
**operations.ts:** Implement atomic credit operations using Drizzle's sql template with conditional WHERE and RETURNING:

1. `deductCredits(userId: string, amount: number)` - Atomic credit deduction
   - Uses `sql\`${user.freeCredits} - ${amount}\`` in SET clause
   - WHERE includes `gte(user.freeCredits, amount)` to only update if sufficient
   - Returns `{ success: boolean; remaining: number | null }`
   - If `result.length === 0`, return `{ success: false, remaining: null }`

2. `refundCredits(userId: string, amount: number)` - Credit refund on failure
   - Simple atomic increment: `sql\`${user.freeCredits} + ${amount}\``
   - No WHERE condition on balance (refunds always succeed)
   - Returns `{ success: boolean; remaining: number }`

3. `deductChatMessage(userId: string, userLevel: UserLevel)` - Chat message deduction
   - Early return for paid/demo users: `{ success: true, remaining: null }` (null = unlimited)
   - For free users: atomic decrement with `gte(user.freeChatMessages, 1)`
   - Returns `{ success: boolean; remaining: number | null }`

4. `withCreditReservation<T>(userId: string, creditCost: number, operation: () => Promise<T>)` - Reserve-execute-refund pattern
   - Deduct credits before operation
   - If deduct fails, throw InsufficientCreditsError
   - Execute operation in try block
   - In catch: refund credits, then rethrow
   - Return operation result on success

**index.ts:** Re-export public API:
```typescript
export { CREDIT_COSTS, getDocumentCost, type DocumentType } from './costs';
export { deductCredits, refundCredits, deductChatMessage, withCreditReservation } from './operations';
export { InsufficientCreditsError, InsufficientChatMessagesError } from './errors';
```

**Import pattern for Drizzle:**
```typescript
import { sql, eq, and, gte } from 'drizzle-orm';
import { db, user } from '@bragdoc/database';
import type { UserLevel } from '@bragdoc/database/schema';
```
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `deductCredits` uses atomic UPDATE with WHERE condition
    - `withCreditReservation` catches errors and refunds before rethrowing
    - All functions handle paid/demo user bypass where applicable
  </verify>
  <done>
    - Atomic deductCredits prevents race conditions via single UPDATE with WHERE
    - withCreditReservation provides reserve-execute-refund pattern for streaming
    - Chat message deduction skips decrement for paid/demo users
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **TypeScript Compilation:**
   ```bash
   pnpm build
   ```
   Must complete without errors.

2. **Module Import Test:**
   ```typescript
   import { CREDIT_COSTS, deductCredits, withCreditReservation, InsufficientCreditsError } from '@/lib/credits';
   ```
   All exports must be accessible.

3. **Pattern Verification:**
   - Grep for atomic pattern: `grep -r "sql\`.*freeCredits.*-" apps/web/lib/credits/`
   - Grep for WHERE condition: `grep -r "gte.*freeCredits" apps/web/lib/credits/`
</verification>

<success_criteria>
- [ ] `lib/credits/` module exists with all required files
- [ ] CREDIT_COSTS defines costs for document_generation, workstream_clustering, chat_tool_call
- [ ] deductCredits uses atomic UPDATE with conditional WHERE
- [ ] withCreditReservation reserves upfront and refunds on error
- [ ] deductChatMessage skips decrement for paid/demo users
- [ ] All TypeScript compiles without errors
- [ ] pnpm build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/02-credit-system/02-01-SUMMARY.md`
</output>
